<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Orbital Shield v7.2 - Black Screen Fix</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            background: #0d0d1a;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            border: 2px solid rgba(0, 255, 255, 0.7);
            cursor: none;
        }
        canvas { display: block; transition: background-image 1s ease-in-out; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; z-index: 5; }
        #stats { display: flex; justify-content: space-between; font-size: 1.5rem; text-shadow: 0 0 5px #0ff; }
        .bar-container { position: absolute; width: 200px; height: 15px; background: rgba(255, 255, 255, 0.2); border-radius: 10px; border: 1px solid #0ff; }
        #health-bar-container { bottom: 20px; left: 50%; transform: translateX(-50%); }
        #overcharge-bar-container { bottom: 45px; left: 50%; transform: translateX(-50%); border-color: #ffc107; }
        #boss-health-bar-container { top: 60px; left: 50%; transform: translateX(-50%); border-color: #f00; opacity: 0; transition: opacity 0.5s ease; }
        #boss-health-bar-container.visible { opacity: 1; }
        .bar { width: 100%; height: 100%; border-radius: 10px; transition: width 0.3s ease; }
        #health-bar { background: #0ff; }
        #overcharge-bar { background: #ffc107; }
        #boss-health-bar { background: #f00; }
        .modal { 
            position: absolute; top: 0; left: 0; 
            width: 100%; height: 100%; 
            background: rgba(13, 13, 26, 0.9); 
            display: flex; flex-direction: column; 
            justify-content: center; align-items: center; 
            text-align: center; 
            pointer-events: all; 
            cursor: default; 
            z-index: 10; 
            opacity: 1; 
            transition: opacity 0.3s ease; 
        }
        .modal.hidden { 
            opacity: 0; 
            pointer-events: none; 
        }
        h1 { font-size: 4rem; text-shadow: 0 0 15px #0ff, 0 0 25px #0ff; }
        h2 { font-size: 2.5rem; margin-bottom: 10px; text-shadow: 0 0 10px #fff; }
        p { font-size: 1.2rem; margin-top: 20px; max-width: 80%; }
        button { padding: 15px 30px; font-size: 1.5rem; background: transparent; border: 2px solid #0ff; color: #0ff; cursor: pointer; margin-top: 20px; transition: all 0.3s ease; display: flex; align-items: center; gap: 10px; text-shadow: 0 0 5px #0ff; }
        button:hover { background: #0ff; color: #0d0d1a; box-shadow: 0 0 20px #0ff; text-shadow: none; }
        button:disabled { border-color: #555; color: #555; cursor: not-allowed; text-shadow: none; }
        button:disabled:hover { background: transparent; box-shadow: none; }
        .button-group { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        #upgrade-screen { justify-content: flex-start; padding-top: 50px; }
        .upgrade-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 30px; width: 90%; max-width: 600px; }
        .upgrade-card { background: rgba(0, 255, 255, 0.1); border: 1px solid #0ff; border-radius: 10px; padding: 20px; text-align: center; }
        .upgrade-card h3 { font-size: 1.5rem; }
        .upgrade-card .level { font-size: 1rem; color: #aaa; margin: 5px 0; }
        .upgrade-card .cost { font-size: 1.2rem; color: #0ff; font-weight: bold; margin-top: 10px; }
        #boss-warning, #stage-clear, #get-ready { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 5rem; color: #f00; text-shadow: 0 0 20px #f00; opacity: 0; pointer-events: none; z-index: 20; animation: warning-flash 2.5s ease-out forwards; }
        #stage-clear { color: #0ff; text-shadow: 0 0 20px #0ff; }
        #get-ready { color: #ffc107; text-shadow: 0 0 20px #ffc107; animation-duration: 3.5s; }
        @keyframes warning-flash { 0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } 10%, 90% { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="game-canvas"></canvas>
    <div id="ui-layer">
        <div id="stats">
            <div id="score">Score: 0</div>
            <div id="total-xp">XP: 0</div>
        </div>
        <div id="boss-health-bar-container" class="bar-container"><div id="boss-health-bar" class="bar"></div></div>
        <div id="overcharge-bar-container" class="bar-container"><div id="overcharge-bar" class="bar"></div></div>
        <div id="health-bar-container" class="bar-container"><div id="health-bar" class="bar"></div></div>
    </div>
    <div id="start-screen" class="modal">
        <h1>Orbital Shield</h1>
        <p>Move shield, Tap to shoot. Press SPACE or Double-Tap for Overcharge!</p>
        <div class="button-group">
            <button id="start-button"><i class="fas fa-play"></i> Start Game</button>
            <button id="fullscreen-button"><i class="fas fa-expand"></i> Full Screen</button>
        </div>
    </div>
    <div id="game-over-screen" class="modal hidden">
        <h2>Game Over</h2>
        <div id="final-score" style="font-size: 1.5rem;"></div>
        <div id="xp-earned" style="font-size: 1.2rem; color: #0ff;"></div>
        <div class="button-group">
            <button id="continue-button"><i class="fas fa-heart"></i> Continue (Ad)</button>
            <button id="restart-button"><i class="fas fa-redo"></i> Play Again</button>
            <button id="upgrades-button"><i class="fas fa-arrow-up"></i> Upgrades</button>
        </div>
    </div>
    <div id="upgrade-screen" class="modal hidden">
        <h2>Upgrades</h2>
        <p>Use your XP to buy permanent upgrades!</p>
        <div class="upgrade-grid"></div>
        <button id="back-to-menu-button"><i class="fas fa-arrow-left"></i> Back to Menu</button>
    </div>
</div>

<script>
// ===================================================================================
//  Orbital Shield v7.2 - Black Screen Fix
// ===================================================================================
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const gameContainer = document.getElementById('game-container');
// UI Elements
const scoreEl = document.getElementById('score'), totalXpEl = document.getElementById('total-xp'),
      healthBarEl = document.getElementById('health-bar'),
      overchargeBarEl = document.getElementById('overcharge-bar'),
      bossHealthBarContainer = document.getElementById('boss-health-bar-container'),
      bossHealthBarEl = document.getElementById('boss-health-bar'),
      startScreen = document.getElementById('start-screen'), gameOverScreen = document.getElementById('game-over-screen'),
      upgradeScreen = document.getElementById('upgrade-screen'),
      startButton = document.getElementById('start-button'), restartButton = document.getElementById('restart-button'),
      continueButton = document.getElementById('continue-button'),
      fullscreenButton = document.getElementById('fullscreen-button'), upgradesButton = document.getElementById('upgrades-button'),
      backToMenuButton = document.getElementById('back-to-menu-button'),
      finalScoreEl = document.getElementById('final-score'), xpEarnedEl = document.getElementById('xp-earned');

let canvasSize, center;
let player, projectiles, enemyProjectiles, enemies, boss, particles, powerUps;
let score, totalXp, isGameOver, animationFrameId, lastShotTime = 0;
let stage = 1, scoreThresholdForBoss = 1000;
let currentMusic = null;
let hasContinued = false;

const upgrades = {
    shieldSize: { level: 1, baseCost: 1000, costMultiplier: 1.5, name: 'Shield Size' },
    fireRate: { level: 1, baseCost: 1500, costMultiplier: 1.8, name: 'Fire Rate' },
    planetHealth: { level: 1, baseCost: 2000, costMultiplier: 2, name: 'Planet Health' },
    projectileDamage: { level: 1, baseCost: 2500, costMultiplier: 1.7, name: 'Attack Power' },
    shieldOvercharge: { level: 0, baseCost: 10000, costMultiplier: 2.5, name: 'Shield Overcharge' },
};

let audioCtx; const sounds = {};
function initAudio() { if (audioCtx) return; try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); const createSound = (freq, type, duration, volume) => () => { if (!audioCtx) return; const o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination); o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime); g.gain.setValueAtTime(volume, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration); o.start(audioCtx.currentTime); o.stop(audioCtx.currentTime + duration); }; sounds.laser = createSound(440, 'triangle', 0.1, 0.3); sounds.explosion = createSound(110, 'square', 0.3, 0.5); sounds.hit = createSound(880, 'sine', 0.2, 0.4); sounds.powerup = createSound(660, 'sine', 0.3, 0.6); sounds.enemyLaser = createSound(220, 'sawtooth', 0.15, 0.2); } catch (e) { console.error("Web Audio API is not supported."); } }
function toggleFullScreen() { if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(err => alert(`Error: ${err.message}`)); else if (document.exitFullscreen) document.exitFullscreen(); }
function resizeGame() { const isFullScreen = !!document.fullscreenElement; canvasSize = isFullScreen ? Math.min(window.innerWidth, window.innerHeight) : Math.min(window.innerWidth, window.innerHeight) * 0.9; canvas.width = canvasSize; canvas.height = canvasSize; gameContainer.style.width = `${canvasSize}px`; gameContainer.style.height = `${canvasSize}px`; center = { x: canvas.width / 2, y: canvas.height / 2 }; if (player) { player.x = center.x; player.y = center.y; } }
function loadData() { totalXp = parseInt(localStorage.getItem('orbitalShieldXP')) || 0; const savedUpgrades = JSON.parse(localStorage.getItem('orbitalShieldUpgrades')); if (savedUpgrades) Object.assign(upgrades, savedUpgrades); totalXpEl.textContent = `XP: ${totalXp}`; }
function saveData() { localStorage.setItem('orbitalShieldXP', totalXp); localStorage.setItem('orbitalShieldUpgrades', JSON.stringify(upgrades)); }

class Player {
    constructor(x, y) {
        this.x = x; this.y = y; this.radius = 30; this.color = '#005f7a';
        this.shield = { angle: 0, radius: this.radius * 1.5, arc: (Math.PI / 4) * (1 + (upgrades.shieldSize.level - 1) * 0.1), color: '#0ff' };
        this.maxHealth = 100 + (upgrades.planetHealth.level - 1) * 50;
        this.health = this.maxHealth;
        this.overcharge = { ready: true, duration: 3000, cooldown: 10000, timer: 0, active: false };
    }
    draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false); ctx.fillStyle = this.color; ctx.fill(); ctx.beginPath(); let shieldRadius = this.shield.radius; let shieldColor = this.shield.color; if (this.overcharge.active) { shieldRadius *= 2; shieldColor = '#ffc107'; } ctx.arc(this.x, this.y, shieldRadius, this.shield.angle - this.shield.arc, this.shield.angle + this.shield.arc, false); ctx.strokeStyle = shieldColor; ctx.lineWidth = this.overcharge.active ? 10 : 5; ctx.stroke(); }
    update(mouse) { this.shield.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x); this.draw(); }
    takeDamage(amount) {
        this.health -= amount;
        healthBarEl.style.width = `${Math.max(0, this.health / this.maxHealth) * 100}%`;
        if (this.health <= 0) endGame();
    }
    activateOvercharge() { if (!this.overcharge.ready || upgrades.shieldOvercharge.level === 0) return; this.overcharge.ready = false; this.overcharge.active = true; this.overcharge.timer = this.overcharge.cooldown; const wave = { x: this.x, y: this.y, radius: this.shield.radius * 2, alpha: 1 }; const waveInterval = setInterval(() => { wave.radius += 10; wave.alpha -= 0.05; if(wave.alpha <= 0) clearInterval(waveInterval); ctx.beginPath(); ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2); ctx.strokeStyle = `rgba(255, 193, 7, ${wave.alpha})`; ctx.lineWidth = 5; ctx.stroke(); [...enemies, boss].filter(e => e).forEach((enemy, eIndex) => { const dist = Math.hypot(enemy.x - wave.x, enemy.y - wave.y); if (dist < wave.radius && dist > wave.radius - 20) { if (enemy instanceof Boss) enemy.takeDamage(50); else { createExplosion(enemy); if(enemy.shootInterval) clearInterval(enemy.shootInterval); enemies.splice(eIndex, 1); } } }); }, 16); setTimeout(() => this.overcharge.active = false, this.overcharge.duration); const cooldownInterval = setInterval(() => { this.overcharge.timer -= 100; overchargeBarEl.style.width = `${100 - (this.overcharge.timer / this.overcharge.cooldown) * 100}%`; if (this.overcharge.timer <= 0) { this.overcharge.ready = true; clearInterval(cooldownInterval); } }, 100); }
}
class Projectile { constructor(x, y, radius, color, velocity) { this.x=x; this.y=y; this.radius=radius; this.color=color; this.velocity=velocity; } draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2, false); ctx.fillStyle=this.color; ctx.fill(); } update() { this.draw(); this.x+=this.velocity.x; this.y+=this.velocity.y; } }
class Enemy extends Projectile { constructor(x, y, radius, color, velocity) { super(x, y, radius, color, velocity); this.maxHealth = this.radius; this.health = this.maxHealth; } takeDamage(amount) { this.health -= amount; if (this.health <= 0) return true; return false; } }
class ShooterEnemy extends Enemy { constructor(x,y,radius,color,velocity){ super(x,y,radius,color,velocity); this.shootInterval = setInterval(()=>this.shoot(), 1800); } shoot(){ if(isGameOver || !player) return; sounds.enemyLaser(); const angle = Math.atan2(player.y-this.y, player.x-this.x); const speed = canvasSize/180; const vel = {x:Math.cos(angle)*speed, y:Math.sin(angle)*speed}; enemyProjectiles.push(new Projectile(this.x, this.y, 5, '#ff4d4d', vel)); }}
class HomingMissile extends Enemy { update(){ if(!player) return; const angle = Math.atan2(player.y-this.y, player.x-this.x); this.velocity.x += Math.cos(angle) * 0.025; this.velocity.y += Math.sin(angle) * 0.025; const speed = Math.hypot(this.velocity.x, this.velocity.y); const maxSpeed = canvasSize/350; if(speed > maxSpeed){ this.velocity.x = (this.velocity.x/speed) * maxSpeed; this.velocity.y = (this.velocity.y/speed) * maxSpeed; } super.update(); }}
class Particle extends Projectile { constructor(x, y, radius, color, velocity, friction = 0.99) { super(x, y, radius, color, velocity); this.friction = friction; this.alpha = 1; } update() { ctx.save(); ctx.globalAlpha = this.alpha; super.update(); ctx.restore(); this.velocity.x *= this.friction; this.velocity.y *= this.friction; this.alpha -= 0.02; } }
class PowerUp extends Projectile { constructor(x, y, radius, color, velocity, type) { super(x, y, radius, color, velocity); this.type = type; } draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false); ctx.fillStyle = this.color; ctx.fill(); ctx.fillStyle = '#0d0d1a'; ctx.font = `bold ${this.radius}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; let symbol = '?'; if(this.type === 'heal') symbol = 'â™¥'; if(this.type === 'tripleShot') symbol = '|||'; ctx.fillText(symbol, this.x, this.y); } }
class Boss extends Enemy { constructor(x, y, radius, color, velocity) { super(x, y, radius, color, velocity); this.maxHealth = (300 + (score / 100)) * stage; this.health = this.maxHealth; this.attackInterval = setInterval(() => this.attack(), 2500); } draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.fill(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.stroke(); } takeDamage(amount) { this.health -= amount; bossHealthBarEl.style.width = `${Math.max(0, this.health / this.maxHealth) * 100}%`; if (this.health <= 0) this.die(); } attack() { if (isGameOver || !player) return; const attackType = Math.random(); if (attackType < 0.5) { for(let i=0; i<10; i++) { const angle = (Math.PI * 2 / 10) * i; const speed = canvasSize/200; const vel = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed }; enemyProjectiles.push(new Projectile(this.x, this.y, 6, this.color, vel)); } } else { for(let i=0; i<4; i++) { const angle = Math.atan2(player.y-this.y, player.x-this.x) + (Math.random() - 0.5); const speed = canvasSize/450; const vel = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed }; enemies.push(new HomingMissile(this.x, this.y, 12, this.color, vel)); } } } die() { if (sounds.explosion) sounds.explosion(); updateScore(1000 * stage); createExplosion(this); bossHealthBarContainer.classList.remove('visible'); clearInterval(this.attackInterval); boss = null; nextStage(); } }

let enemyInterval, powerupInterval;
function init() {
    isGameOver = false;
    stage = 1;
    score = upgrades.startingScore.level * 500;
    scoreThresholdForBoss = 1000;
    hasContinued = false;
    
    scoreEl.textContent = `Score: ${score}`;
    player = new Player(center.x, center.y);
    healthBarEl.style.width = '100%';
    overchargeBarEl.style.width = '100%';
    
    projectiles = []; enemyProjectiles = []; enemies = []; particles = []; powerUps = []; boss = null;

    gameOverScreen.classList.add('hidden');
    upgradeScreen.classList.add('hidden');
    bossHealthBarContainer.classList.remove('visible');

    startScreen.classList.add('hidden'); // Hide start screen
    
    // Clear any existing game loops before starting new ones
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    if (enemyInterval) clearInterval(enemyInterval);
    if (powerupInterval) clearInterval(powerupInterval);
    
    startStage(1);
    animate();
}

function startStage(newStage) {
    stage = newStage;
    const stageData = stages[(stage - 1) % stages.length];
    canvas.style.backgroundImage = `url("${stageData.bg}")`;
    if (currentMusic) { currentMusic.pause(); }
    try {
        currentMusic = new Audio(stageData.music);
        currentMusic.loop = true; currentMusic.volume = 0.3;
        currentMusic.play().catch(e => console.error("Audio play failed:", e));
    } catch(e) { console.error("Failed to load audio:", e); }
    if (enemyInterval) clearInterval(enemyInterval);
    if (powerupInterval) clearInterval(powerupInterval);
    enemyInterval = spawnEnemies();
    powerupInterval = spawnPowerUps();
}

function nextStage() {
    projectiles = []; enemyProjectiles = []; enemies = [];
    showStageClearScreen(`Stage ${stage} Cleared!`);
    setTimeout(() => {
        const next = stage + 1;
        scoreThresholdForBoss *= 1.5;
        player.health = player.maxHealth;
        healthBarEl.style.width = '100%';
        showStageClearScreen(`Get Ready: Stage ${next}`, 'get-ready');
        setTimeout(() => startStage(next), 500);
    }, 2500);
}

function spawnEnemies() { return setInterval(() => { if (isGameOver || boss) return; const radius = Math.random() * (canvasSize / 40) + (canvasSize / 80); let x, y; if (Math.random() < 0.5) { x = Math.random() < 0.5 ? 0 - radius : canvas.width + radius; y = Math.random() * canvas.height; } else { x = Math.random() * canvas.width; y = Math.random() < 0.5 ? 0 - radius : canvas.height + radius; } const angle = Math.atan2(center.y - y, center.x - x); const speed = (canvasSize / 320) + (score / 10000) * stage; const velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed }; const enemyType = Math.random(); if (enemyType < 0.6) { enemies.push(new Enemy(x, y, radius, `hsl(${Math.random() * 360}, 50%, 50%)`, velocity)); } else if (enemyType < 0.85) { enemies.push(new ShooterEnemy(x, y, radius * 0.8, '#f0ad4e', velocity)); } else { enemies.push(new HomingMissile(x, y, radius * 0.7, '#d9534f', velocity)); } }, 800 / stage); }
function spawnPowerUps() { return setInterval(()=>{if(isGameOver)return;const t=canvasSize/50;let o,n;Math.random()<.5?(o=Math.random()<.5?0-t:canvas.width+t,n=Math.random()*canvas.height):(o=Math.random()*canvas.width,n=Math.random()<.5?0-t:canvas.height+t);const e=Math.atan2(center.y-n,center.x-o),a={x:Math.cos(e),y:Math.sin(e)},i=Math.random()<.5?"heal":"tripleShot",s="heal"===i?"#28a745":"#ffc107";powerUps.push(new PowerUp(o,n,t,s,a,i))},15e3)};
function createExplosion(obj) { if (sounds.explosion) sounds.explosion(); for(let i=0; i<obj.radius*2; i++){ const speed=Math.random()*6; const angle=Math.random()*Math.PI*2; const velocity={x:Math.cos(angle)*speed, y:Math.sin(angle)*speed}; particles.push(new Particle(obj.x, obj.y, Math.random()*3, obj.color, velocity)); } }
function updateScore(amount) { score += amount; scoreEl.textContent = `Score: ${score}`; if (!boss && score >= scoreThresholdForBoss) spawnBoss(); }

function spawnBoss() {
    enemies.forEach(e => { if (e.shootInterval) clearInterval(e.shootInterval); });
    enemies = [];
    showStageClearScreen('WARNING!', 'boss-warning');
    const radius = 50; const x = Math.random()<0.5 ? 0-radius : canvas.width+radius; const y = Math.random()*canvas.height; const angle = Math.atan2(center.y-y, center.x-x); const velocity = {x:Math.cos(angle)*1.2, y:Math.sin(angle)*1.2};
    boss = new Boss(x, y, radius, '#8a2be2', velocity);
    bossHealthBarContainer.classList.add('visible');
    bossHealthBarEl.style.width = '100%';
}

function showStageClearScreen(text, id = 'stage-clear') { const el = document.createElement('div'); el.id = id; el.textContent = text; gameContainer.appendChild(el); setTimeout(() => el.remove(), id === 'get-ready' ? 3500 : 2500); }

function animate() {
    if (isGameOver) return;
    animationFrameId = requestAnimationFrame(animate);
    ctx.fillStyle = 'rgba(13, 13, 26, 0.2)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    player.update(mouse);
    if (boss) boss.update();
    particles.forEach((p, i) => { if (p.alpha <= 0) particles.splice(i, 1); else p.update(); });
    projectiles.forEach((p, i) => { if (p.x + p.radius < 0 || p.x - p.radius > canvas.width || p.y + p.radius < 0 || p.y - p.radius > canvas.height) setTimeout(() => projectiles.splice(i, 1), 0); else p.update(); });
    enemyProjectiles.forEach((ep, epIndex) => { ep.update(); const dist = Math.hypot(ep.x - player.x, ep.y - player.y); if (dist - ep.radius - player.radius < 1) { player.takeDamage(10); if (sounds.hit) sounds.hit(); setTimeout(() => enemyProjectiles.splice(epIndex, 1), 0); } });
    if (boss) {
        projectiles.forEach((proj, pIndex) => {
            const dist = Math.hypot(proj.x - boss.x, proj.y - boss.y);
            if (dist - boss.radius - proj.radius < 1) {
                boss.takeDamage(5 * upgrades.projectileDamage.level); updateScore(15); createExplosion({x: proj.x, y: proj.y, radius: 10, color: proj.color});
                setTimeout(() => projectiles.splice(pIndex, 1), 0);
            }
        });
    }
    enemies.forEach((enemy, eIndex) => {
        enemy.update();
        const distToPlayer = Math.hypot(enemy.x - player.x, enemy.y - player.y);
        if (distToPlayer - enemy.radius - player.radius < 1) { if (sounds.hit) sounds.hit(); player.takeDamage(enemy.radius); createExplosion(enemy); if (enemy.shootInterval) clearInterval(enemy.shootInterval); setTimeout(() => enemies.splice(eIndex, 1), 0); }
        const angleToEnemy = Math.atan2(enemy.y - player.y, enemy.x - player.x);
        let angleDiff = player.shield.angle - angleToEnemy; while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI; while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        const shieldRadius = player.overcharge.active ? player.shield.radius * 2 : player.shield.radius;
        const distToShield = Math.hypot(enemy.x - player.x, enemy.y - player.y);
        if (distToShield - enemy.radius - shieldRadius < 1 && Math.abs(angleDiff) < player.shield.arc) { if (sounds.hit) sounds.hit(); updateScore(10); createExplosion(enemy); if (enemy.shootInterval) clearInterval(enemy.shootInterval); setTimeout(() => enemies.splice(eIndex, 1), 0); }
        projectiles.forEach((proj, pIndex) => { const dist = Math.hypot(proj.x - enemy.x, proj.y - enemy.y); if (dist - enemy.radius - proj.radius < 1) { if (enemy.takeDamage(10 * upgrades.projectileDamage.level)) { updateScore(50); if (enemy.shootInterval) clearInterval(enemy.shootInterval); setTimeout(() => enemies.splice(eIndex, 1), 0); } else { updateScore(25); } createExplosion(enemy); setTimeout(() => projectiles.splice(pIndex, 1), 0); } });
    });
    powerUps.forEach((p, pIndex) => { p.update(); const dist = Math.hypot(p.x - player.x, p.y - player.y); if(dist-p.radius-player.radius<1){ if(sounds.powerup) sounds.powerup(); if(p.type==='heal') player.health = Math.min(player.maxHealth, player.health + 25); if(p.type==='tripleShot') shoot(3); healthBarEl.style.width=`${(player.health/player.maxHealth)*100}%`; setTimeout(()=>powerUps.splice(pIndex,1),0);}});
}

function endGame() {
    isGameOver = true; cancelAnimationFrame(animationFrameId);
    clearInterval(enemyInterval); clearInterval(powerupInterval);
    enemies.forEach(e => { if(e.shootInterval) clearInterval(e.shootInterval); });
    if (boss && boss.attackInterval) clearInterval(boss.attackInterval);
    if (currentMusic) currentMusic.pause();
    
    if (hasContinued) {
        const xpEarned = Math.floor(score / 100); totalXp += xpEarned;
        saveData();
        finalScoreEl.textContent = `Your Final Score: ${score}`;
        xpEarnedEl.textContent = `You earned ${xpEarned} XP!`;
        totalXpEl.textContent = `XP: ${totalXp}`;
        continueButton.style.display = 'none';
    } else {
        finalScoreEl.textContent = `Your Score: ${score}`;
        xpEarnedEl.textContent = `Watch an ad to continue with 75% health?`;
        continueButton.style.display = 'flex';
    }
    
    gameOverScreen.classList.remove('hidden');
}

function continueGame() {
    const continueBtn = continueButton;
    continueBtn.disabled = true; continueBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading Ad...';
    
    if (typeof show_s === 'function') {
        show_s().catch(err => console.error("Ad error:", err)).finally(() => {
            isGameOver = false; hasContinued = true;
            player.health = player.maxHealth * 0.75; // Continue with 75% health
            healthBarEl.style.width = '75%';
            gameOverScreen.classList.add('hidden');
            if (currentMusic) currentMusic.play();
            enemyInterval = spawnEnemies();
            powerupInterval = spawnPowerUps();
            animate();
            continueBtn.disabled = false; continueBtn.innerHTML = '<i class="fas fa-heart"></i> Continue (Ad)';
        });
    } else {
        alert("Ad library not loaded. Cannot continue.");
        continueBtn.disabled = false; continueBtn.innerHTML = '<i class="fas fa-heart"></i> Continue (Ad)';
    }
}

const mouse = { x: 0, y: 0 }; let activeTouchId = null;
gameContainer.addEventListener('mousemove', (e) => { const rect = canvas.getBoundingClientRect(); mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; });
gameContainer.addEventListener('touchmove', (e) => { e.preventDefault(); if(e.touches.length > 0){ const rect = canvas.getBoundingClientRect(); if(activeTouchId === null) activeTouchId = e.touches[0].identifier; for(let i=0; i < e.touches.length; i++){ if(e.touches[i].identifier === activeTouchId){ mouse.x = e.touches[i].clientX-rect.left; mouse.y = e.touches[i].clientY-rect.top; break; } } } }, { passive: false });
gameContainer.addEventListener('touchend', (e) => { if(e.touches.length === 0) activeTouchId = null; });
let lastTapTime = 0;
gameContainer.addEventListener('touchstart', (e) => {
    if (isGameOver || !startScreen.classList.contains('hidden')) return;
    e.preventDefault();
    const now = Date.now();
    if(now - lastTapTime < 300 && e.touches.length === 1) { player.activateOvercharge(); }
    lastTapTime = now;
    if (e.touches.length > 1 && e.changedTouches[0].identifier !== activeTouchId || e.touches.length === 1) { shoot(); }
});
gameContainer.addEventListener('click', () => { if(!isGameOver && !startScreen.classList.contains('hidden')) shoot(); });
window.addEventListener('keydown', (e) => { if(e.code === 'Space' && !isGameOver && player) player.activateOvercharge(); });

function shoot(count = 1) {
    if (isGameOver || startScreen.classList.contains('hidden') === false || !player) return;
    const fireRate = 400 - (upgrades.fireRate.level - 1) * 35;
    const now = Date.now();
    if (now - lastShotTime < fireRate) return;
    lastShotTime = now;
    if (sounds.laser) sounds.laser();
    const spread = Math.PI / 12;
    for (let i = 0; i < count; i++) {
        let angle = player.shield.angle;
        if (count > 1) angle = player.shield.angle - spread + (spread * 2 / (count - 1)) * i;
        const velocity = { x: Math.cos(angle) * 8, y: Math.sin(angle) * 8 };
        projectiles.push(new Projectile(center.x, center.y, 5, '#0ff', velocity));
    }
}

function renderUpgrades() { const grid = document.querySelector('.upgrade-grid'); grid.innerHTML = ''; for (const key in upgrades) { const upg = upgrades[key]; const cost = Math.floor(upg.baseCost * Math.pow(upg.costMultiplier, upg.level)); const card = document.createElement('div'); card.className = 'upgrade-card'; card.innerHTML = `<h3>${upg.name}</h3> <div class="level">Level: ${upg.level}</div> <div class="cost">Cost: ${cost} XP</div> <button class="upgrade-btn" data-key="${key}" ${totalXp < cost ? 'disabled' : ''}>Upgrade</button>`; grid.appendChild(card); } document.querySelectorAll('.upgrade-btn').forEach(btn => btn.onclick = () => buyUpgrade(btn.dataset.key)); }
function buyUpgrade(key) { const upg = upgrades[key]; const cost = Math.floor(upg.baseCost * Math.pow(upg.costMultiplier, upg.level)); if (totalXp >= cost) { totalXp -= cost; upg.level++; totalXpEl.textContent = `XP: ${totalXp}`; saveData(); renderUpgrades(); } }

startButton.addEventListener('click', () => { initAudio(); init(); });
restartButton.addEventListener('click', init);
continueButton.addEventListener('click', continueGame);
fullscreenButton.addEventListener('click', toggleFullScreen);
upgradesButton.addEventListener('click', () => { gameOverScreen.classList.add('hidden'); renderUpgrades(); upgradeScreen.classList.remove('hidden'); });
backToMenuButton.addEventListener('click', () => { upgradeScreen.classList.add('hidden'); startScreen.classList.remove('hidden'); });
window.addEventListener('resize', resizeGame);
document.addEventListener("fullscreenchange", resizeGame);

// Initial setup
resizeGame();
loadData();
</script>
<script src='//libtl.com/sdk.js' data-zone='9563904' data-sdk='show_s' async></script>
</body>
</html>
